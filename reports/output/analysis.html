<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Analyses of the experimental results</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="analysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="analysis_files/libs/quarto-html/quarto.js"></script>
<script src="analysis_files/libs/quarto-html/popper.min.js"></script>
<script src="analysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="analysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="analysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="analysis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="analysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="analysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="analysis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Analyses of the experimental results</h1>
</div>



<div class="quarto-title-meta">




  </div>


</header>

<section id="benchmark-results" class="level2">
<h2 class="anchored" data-anchor-id="benchmark-results">Benchmark results</h2>
<section id="synthetic-dataset" class="level3">
<h3 class="anchored" data-anchor-id="synthetic-dataset">Synthetic dataset</h3>
<p>For each method, we select the hyperparameter based on their <em>cost efficiency</em>, i.e., the achieved accuracy (PRC) per unit acquisition cost. We ignore the sensing policies that made no observation (cost = 0). The benchmark result of RAS agains baselines are shown as follows.</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Benchmark evaluation on the synthetic dataset.</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode markdown code-overflow-wrap code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-fold: true</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-summary: Benchmark evaluation on the synthetic dataset.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-overflow: wrap</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>grouped <span class="op">=</span> metrics.groupby([<span class="st">"method"</span>, <span class="st">"params"</span>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>metrics.columns)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (m, g) <span class="kw">in</span> <span class="bu">enumerate</span>(grouped):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> g[scores].<span class="bu">apply</span>(mean_confidence_interval)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> stats.iloc[:<span class="dv">2</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">.</span>iloc[<span class="dv">0</span>]<span class="sc">:.3f}</span><span class="ss">±</span><span class="sc">{</span>x<span class="sc">.</span>iloc[<span class="dv">1</span>]<span class="sc">:.3f}</span><span class="ss">"</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    df.loc[i] <span class="op">=</span> stats</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    df.loc[i, [<span class="st">"method"</span>, <span class="st">"params"</span>]] <span class="op">=</span> m</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> []</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>report.append(df[df[<span class="st">"method"</span>] <span class="op">==</span> <span class="st">"FO"</span>])</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, g <span class="kw">in</span> df.groupby(<span class="st">"method"</span>):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="st">"FO"</span>:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For each method, we select the most "cost-efficient" model for the benchmark.</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Thus, we consider the accuracy (PRC) per unit acquisition cost.</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    prc <span class="op">=</span> g[<span class="st">"prc"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> s: <span class="bu">float</span>(s.split(<span class="st">"±"</span>)[<span class="dv">0</span>]))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> g[<span class="st">"cost"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> s: <span class="bu">float</span>(s.split(<span class="st">"±"</span>)[<span class="dv">0</span>]))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> prc <span class="op">/</span> (cost <span class="op">*</span> (cost <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">+</span> <span class="fl">1e10</span> <span class="op">*</span> (cost <span class="op">==</span> <span class="dv">0</span>))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> w.argmax()</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    report.append(g.iloc[[idx]])</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> pd.concat(report)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> report[[<span class="st">"method"</span>, <span class="st">"params"</span>] <span class="op">+</span> scores].rename(</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>{</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">"method"</span>: <span class="st">"Method"</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="st">"params"</span>: <span class="st">"Params"</span>,</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">"roc"</span>: <span class="st">"ROC"</span>,</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="st">"prc"</span>: <span class="st">"PRC"</span>,</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="st">"cost"</span>: <span class="st">"Cost"</span>,</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="st">"delay(p&gt;=0.3)"</span>: <span class="st">"d_{δ=0.3}"</span>,</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="st">"delay(p&gt;=0.5)"</span>: <span class="st">"d_{δ=0.5}"</span>,</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="st">"delay(p&gt;=0.7)"</span>: <span class="st">"d_{δ=0.7}"</span>,</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>display(result)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Method</th>
<th data-quarto-table-cell-role="th">Params</th>
<th data-quarto-table-cell-role="th">ROC</th>
<th data-quarto-table-cell-role="th">PRC</th>
<th data-quarto-table-cell-role="th">Cost</th>
<th data-quarto-table-cell-role="th">d_{δ=0.3}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.5}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.7}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">7</td>
<td>FO</td>
<td></td>
<td>0.680±0.000</td>
<td>0.655±0.000</td>
<td>31.000±0.000</td>
<td>0.502±0.000</td>
<td>0.349±0.000</td>
<td>0.285±0.000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>AS</td>
<td>Δ=1.0</td>
<td>0.671±0.001</td>
<td>0.614±0.001</td>
<td>4.501±0.497</td>
<td>0.577±0.029</td>
<td>0.522±0.012</td>
<td>0.479±0.015</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>ASAC</td>
<td>μ=0.01</td>
<td>0.605±0.096</td>
<td>0.559±0.080</td>
<td>0.460±1.078</td>
<td>1.099±0.664</td>
<td>1.066±0.699</td>
<td>1.052±0.641</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>NLL</td>
<td>λ=100.0</td>
<td>0.636±0.023</td>
<td>0.588±0.016</td>
<td>2.968±0.774</td>
<td>0.993±0.131</td>
<td>0.974±0.141</td>
<td>0.975±0.147</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">13</td>
<td>RAS</td>
<td>λ=300.0</td>
<td>0.680±0.003</td>
<td>0.647±0.006</td>
<td>6.077±0.953</td>
<td>0.325±0.084</td>
<td>0.264±0.086</td>
<td>0.246±0.071</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>In the following table, we mark the location of the best performance in each column and evalute the <span class="math inline">\(p\)</span>-values by performance t-test against the rest methods.</p>
<div class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Method</th>
<th data-quarto-table-cell-role="th">ROC</th>
<th data-quarto-table-cell-role="th">PRC</th>
<th data-quarto-table-cell-role="th">Cost</th>
<th data-quarto-table-cell-role="th">d_{δ=0.3}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.5}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.7}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">7</td>
<td>FO</td>
<td>best</td>
<td>best</td>
<td>0.0</td>
<td>0.000015</td>
<td>0.002506</td>
<td>0.042681</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>AS</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.000002</td>
<td>0.000001</td>
<td>0.000001</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>ASAC</td>
<td>0.009035</td>
<td>0.000765</td>
<td>best</td>
<td>0.000967</td>
<td>0.001065</td>
<td>0.000589</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>NLL</td>
<td>0.000031</td>
<td>0.0</td>
<td>0.000034</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">13</td>
<td>RAS</td>
<td>1.0</td>
<td>0.000386</td>
<td>0.0</td>
<td>best</td>
<td>best</td>
<td>best</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Below, we propose one optional criterion to find the best method by considering both acquisition cost and diagnositic accuracy. We consider the FO baseline with dense sensing histories as a reference, and find the optimal sensing history that achieves the largest acquisition cost reduction while maintaining a reasonable accuracy. Our criterion is defiend as follows for each method (except for the FO baseline). <span class="math display">\[
\frac{\max (0, \mathrm{PRC}_{\mathrm{FO}} - \mathrm{PRC})}{\mathrm{Cost}_{\mathrm{FO}} - \mathrm{Cost}},
\]</span> where a small value indicates more effective active sensing strategy (small loss in accuracy but high reduction in acquisition cost).</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Find the overally best method.</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode markdown code-overflow-wrap code-with-copy"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-fold: true</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-summary: Find the overally best method.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-overflow: wrap</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>perf_fo <span class="op">=</span> report[report[<span class="st">"method"</span>]<span class="op">==</span><span class="st">"FO"</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>rest <span class="op">=</span> report[report[<span class="st">"method"</span>]<span class="op">!=</span><span class="st">"FO"</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>PRC_FO, COST_FO <span class="op">=</span> perf_fo[<span class="st">"prc"</span>].item(), perf_fo[<span class="st">"cost"</span>].item()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>PRC_FO <span class="op">=</span> <span class="bu">float</span>(PRC_FO.split(<span class="st">"±"</span>)[<span class="dv">0</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>COST_FO <span class="op">=</span> <span class="bu">float</span>(COST_FO.split(<span class="st">"±"</span>)[<span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>prc <span class="op">=</span> rest[<span class="st">"prc"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> s: <span class="bu">float</span>(s.split(<span class="st">"±"</span>)[<span class="dv">0</span>]))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> rest[<span class="st">"cost"</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> s: <span class="bu">float</span>(s.split(<span class="st">"±"</span>)[<span class="dv">0</span>]))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> (PRC_FO <span class="op">-</span> prc).clip(<span class="dv">0</span>)<span class="op">/</span>(COST_FO <span class="op">-</span> cost)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> w.argmin()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>best_method <span class="op">=</span> rest.iloc[idx][<span class="st">"method"</span>]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>best_params <span class="op">=</span> rest.iloc[idx][<span class="st">"params"</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Based on the above criterion, the best method is </span><span class="sc">{</span>best_method<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>best_params<span class="sc">}</span><span class="ss">)"</span>) <span class="co"># noqa</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Based on the above criterion, the best method is RAS (λ=300.0)</code></pre>
</div>
</div>
</section>
<section id="adni-dataset" class="level3">
<h3 class="anchored" data-anchor-id="adni-dataset">ADNI dataset</h3>
<p>We perform similar analysis on the ADNI dataset. The benchmark results are given below.</p>
<div class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Method</th>
<th data-quarto-table-cell-role="th">Params</th>
<th data-quarto-table-cell-role="th">ROC</th>
<th data-quarto-table-cell-role="th">PRC</th>
<th data-quarto-table-cell-role="th">Cost</th>
<th data-quarto-table-cell-role="th">d_{δ=0.1}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.3}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.5}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>FO</td>
<td></td>
<td>0.747±0.000</td>
<td>0.577±0.000</td>
<td>26.865±0.000</td>
<td>0.141±0.000</td>
<td>0.510±0.000</td>
<td>0.591±0.000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>AS</td>
<td>Δ=1.5</td>
<td>0.704±0.023</td>
<td>0.519±0.034</td>
<td>3.566±0.854</td>
<td>1.326±0.096</td>
<td>2.314±0.348</td>
<td>2.357±0.375</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>ASAC</td>
<td>μ=0.1</td>
<td>0.521±0.160</td>
<td>0.352±0.103</td>
<td>0.043±0.186</td>
<td>0.527±0.000</td>
<td>3.008±3.610</td>
<td>3.581±0.000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>NLL</td>
<td>λ=200.0</td>
<td>0.697±0.018</td>
<td>0.512±0.020</td>
<td>3.986±0.493</td>
<td>1.040±0.149</td>
<td>2.176±0.060</td>
<td>2.739±0.135</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">15</td>
<td>RAS</td>
<td>λ=400.0</td>
<td>0.730±0.007</td>
<td>0.560±0.012</td>
<td>8.614±1.157</td>
<td>0.820±0.096</td>
<td>1.370±0.227</td>
<td>1.192±0.176</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The best performance in each column and the overall best method is reported as follows.</p>
<div class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Method</th>
<th data-quarto-table-cell-role="th">ROC</th>
<th data-quarto-table-cell-role="th">PRC</th>
<th data-quarto-table-cell-role="th">Cost</th>
<th data-quarto-table-cell-role="th">delay(p&gt;=0.1)</th>
<th data-quarto-table-cell-role="th">d_{δ=0.3}</th>
<th data-quarto-table-cell-role="th">d_{δ=0.5}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>FO</td>
<td>best</td>
<td>best</td>
<td>0.0</td>
<td>best</td>
<td>best</td>
<td>best</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>AS</td>
<td>0.003157</td>
<td>0.004419</td>
<td>0.000165</td>
<td>0.000002</td>
<td>0.000061</td>
<td>0.000089</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">5</td>
<td>ASAC</td>
<td>0.008679</td>
<td>0.001764</td>
<td>best</td>
<td>0.0</td>
<td>0.078592</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>NLL</td>
<td>0.000705</td>
<td>0.000384</td>
<td>0.000014</td>
<td>0.000034</td>
<td>0.0</td>
<td>0.000001</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">15</td>
<td>RAS</td>
<td>0.00118</td>
<td>0.00859</td>
<td>0.000016</td>
<td>0.000018</td>
<td>0.000211</td>
<td>0.000316</td>
</tr>
</tbody>
</table>

</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Based on our proposed criterion, the best method is RAS (λ=400.0)</code></pre>
</div>
</div>
<p>Our method achieves a desirable balance between diagnosis accuracy and acquisition cost and is evaluated to be the best sensing policy.</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<section id="trade-off-between-timeliness-and-acquisition-costs." class="level3">
<h3 class="anchored" data-anchor-id="trade-off-between-timeliness-and-acquisition-costs.">Trade-off between timeliness and acquisition costs.</h3>
<p>The selection of model parameters could be difficult when two or more criteria are involved in the evaluation. Here, we illustrate the sensing performance of different policies on the synthetic dataset and highlight the ones in the Pareto front with gray circles in <a href="#fig-pareto-front">Figure&nbsp;1</a>.</p>
<div class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div id="fig-pareto-front" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="analysis_files/figure-html/fig-pareto-front-output-1.png" width="564" height="466" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Pareto front of different sensing policies.</figcaption>
</figure>
</div>
</div>
</div>
<p>These policies are considered Pareto optimal since their timeliness (<span class="math inline">\(d_{δ=0.5}\)</span>) and average acquisition cost cannot be simultaneously improved by swapping parameters with other policies. Benefitted from the risk-averse training strategy, most sensing policies obtained via RAS are centered around the knee point of the Pareto front, which helps to explain the outstanding cost efficiency of RAS as reported above.</p>
</section>
<section id="improvement-of-the-sensing-deficiency-distribution" class="level3">
<h3 class="anchored" data-anchor-id="improvement-of-the-sensing-deficiency-distribution">Improvement of the sensing deficiency distribution</h3>
<p>To illustrate the effectiveness of our risk-averse active sensing approach, we compare the empirical distribution of sensing deficiency <span class="math inline">\(Q^π(X)\)</span> of RAS with the ablations of risk-neutral sensing (<span class="math inline">\(α = 1.0\)</span>) and AS baseline (<span class="math inline">\(α = 1.0\)</span>, constant acquisition interval <span class="math inline">\(∆ = 1.0\)</span>) on the synthetic dataset. All three models are trained with the same trade-off coefficient <span class="math inline">\(λ = 300\)</span>. As illustrated in <a href="#fig-sensing-deficiency">Figure&nbsp;2</a>, RAS is able to effectively optimize the sensing performance for trajectories in the long tail of sensing deficency distribution and reduces the upper <span class="math inline">\(α\)</span>-quantile of <span class="math inline">\(Q^π(X)\)</span> to <span class="math inline">\(ρ_{α=0.1} = 10.40\)</span>. Factor α = 1.0 completely disables the risk-aversion training strategy in RAS. Thereby, a clear increase of sensing deficiency (quantile <span class="math inline">\(ρ_{α=0.1}\)</span> grows from 10.40 to 20.01) is observed with the risk-neutral ablation of RAS. Similarly, without adaptive scheduling of acquisition intervals and risk-averse optimization strategies, the AS baseline illustrates the failure of conventional active sensing paradigms at the long tail of <span class="math inline">\(Q^π(X)\)</span> distribution.</p>
<div class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div id="fig-sensing-deficiency" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="analysis_files/figure-html/fig-sensing-deficiency-output-1.png" width="565" height="468" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Distributions of sensing deficiency.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button,
        { trigger: "manual",
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config);
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>
